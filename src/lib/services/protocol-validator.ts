// Protocol Validator Service - Chemical Entity Validation Implementation
// Uses Pyodide (WebAssembly) to securely execute generated Python protocols
// Transitions MASA from "Philosopher" to "Scientist"

import { loadPyodide, PyodideInterface } from 'pyodide';

// Singleton Pyodide instance - heavy (~15MB), reuse across calls
let pyodideInstance: PyodideInterface | null = null;
let pyodideLoading: Promise<PyodideInterface | null> | null = null;
let pyodideAvailable = true; // Graceful degradation flag

export interface ValidationResult {
  success: boolean;
  stdout: string;
  stderr: string;
  metrics?: {
    pValue?: number;
    bayesFactor?: number;
    conclusionValid?: boolean;
    sampleSize?: number;
  };
  executionTimeMs: number;
  error?: string;
  feasibilityScore?: number; // 0-1 score for reaction feasibility
}

/**
 * Phase 3 Engineering: Sanity Gate
 * Validates 'Verbs' (reactions/actions) against physical and chemical constraints.
 */
export class SanityGate {
  private static impossibleVerbs = [
    'react noble gas at stp',
    'extract energy from vacuum',
    'cold fusion at room temperature',
    'impossible yield > 100',
    'perpetual motion'
  ];

  /**
   * Performs a heuristic check on the protocol code for physical impossibilities.
   */
  static evaluate(protocolCode: string): number {
    const codeLower = protocolCode.toLowerCase();
    let score = 1.0;

    for (const verb of this.impossibleVerbs) {
      if (codeLower.includes(verb)) {
        score *= 0.1; // Drastic reduction for impossible verbs
      }
    }

    // Heuristic: check for basic thermodynamic violations (mock)
    if (codeLower.includes('delta_g > 0') && codeLower.includes('spontaneous')) {
      score *= 0.5;
    }

    return score;
  }
}

/**
 * Get or initialize the Pyodide instance with scientific packages
 * Returns null if Pyodide is not available (graceful degradation)
 */
async function getPyodide(): Promise<PyodideInterface | null> {
  // Skip if previously failed
  if (!pyodideAvailable) {
    return null;
  }
  
  if (pyodideInstance) {
    return pyodideInstance;
  }
  
  if (pyodideLoading) {
    return pyodideLoading;
  }
  
  console.log('[ProtocolValidator] Loading Pyodide...');
  
  try {
    // In Node.js, omit indexURL - pyodide npm package handles loading automatically
    // Specifying CDN indexURL causes path concatenation errors in server environments
    pyodideLoading = loadPyodide().then(async (instance) => {
      // Load scientific packages via micropip
      console.log('[ProtocolValidator] Loading scientific packages...');
      await instance.loadPackage(['numpy', 'scipy']);
      
      // Try to load networkx (may not be available in Pyodide)
      try {
        await instance.loadPackage('networkx');
        console.log('[ProtocolValidator] NetworkX loaded');
      } catch {
        console.warn('[ProtocolValidator] NetworkX not available, graphs will fail');
      }
      
      console.log('[ProtocolValidator] Pyodide ready');
      return instance;
    }).catch((error) => {
      console.warn('[ProtocolValidator] Pyodide loading failed, protocol validation disabled:', error.message);
      pyodideAvailable = false;
      return null;
    });
    
    pyodideInstance = await pyodideLoading;
    return pyodideInstance;
    
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.warn('[ProtocolValidator] Pyodide initialization failed:', errorMessage);
    pyodideAvailable = false;
    return null;
  }
}

/**
 * Execute Python protocol code in a secure Pyodide sandbox
 * 
 * @param protocolCode - Python code generated by ExperimentGenerator
 * @param timeoutMs - Maximum execution time (default 30s)
 * @returns Validation result with stdout, metrics, and success flag
 */
export async function validateProtocol(
  protocolCode: string,
  timeoutMs: number = 30000
): Promise<ValidationResult> {
  const startTime = Date.now();
  
  try {
    const pyodide = await getPyodide();
    
    // Graceful degradation: if Pyodide unavailable, skip validation
    if (!pyodide) {
      return {
        success: false,
        stdout: '',
        stderr: '',
        executionTimeMs: Date.now() - startTime,
        error: 'Pyodide not available in this environment - protocol validation skipped'
      };
    }
    
    // Capture stdout
    let stdout = '';
    let stderr = '';
    
    // Set up output capture
    pyodide.runPython(`
import sys
from io import StringIO
_stdout_capture = StringIO()
_stderr_capture = StringIO()
sys.stdout = _stdout_capture
sys.stderr = _stderr_capture
`);
    
    // Execute with timeout
    const executionPromise = pyodide.runPythonAsync(protocolCode);
    
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new Error('Execution timeout')), timeoutMs);
    });
    
    await Promise.race([executionPromise, timeoutPromise]);
    
    // Capture outputs
    stdout = pyodide.runPython(`_stdout_capture.getvalue()`) as string;
    stderr = pyodide.runPython(`_stderr_capture.getvalue()`) as string;
    
    // Reset stdout/stderr for next run
    pyodide.runPython(`
sys.stdout = sys.__stdout__
sys.stderr = sys.__stderr__
`);
    
    // Try to extract metrics from output
    const metrics = parseMetrics(stdout);
    
    // Phase 3: Run Sanity Gate evaluation
    const feasibilityScore = SanityGate.evaluate(protocolCode);
    
    return {
      success: true,
      stdout,
      stderr,
      metrics,
      feasibilityScore,
      executionTimeMs: Date.now() - startTime
    };
    
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('[ProtocolValidator] Execution failed:', errorMessage);
    
    return {
      success: false,
      stdout: '',
      stderr: '',
      executionTimeMs: Date.now() - startTime,
      error: errorMessage
    };
  }
}

/**
 * Parse scientific metrics from stdout
 * Looks for common patterns like "p-value: 0.05" or "Bayes Factor: 3.2"
 */
function parseMetrics(stdout: string): ValidationResult['metrics'] {
  const metrics: ValidationResult['metrics'] = {};
  
  // Match p-value patterns
  const pValueMatch = stdout.match(/p[_-]?value[:\s]+([0-9.e-]+)/i);
  if (pValueMatch) {
    metrics.pValue = parseFloat(pValueMatch[1]);
  }
  
  // Match Bayes factor patterns
  const bfMatch = stdout.match(/bayes[_\s]?factor[:\s]+([0-9.e+-]+)/i);
  if (bfMatch) {
    metrics.bayesFactor = parseFloat(bfMatch[1]);
  }
  
  // Match sample size patterns
  const sampleMatch = stdout.match(/(?:sample[_\s]?size|n)[:\s=]+(\d+)/i);
  if (sampleMatch) {
    metrics.sampleSize = parseInt(sampleMatch[1], 10);
  }
  
  // Determine if conclusion is valid (p < 0.05 or BF > 3)
  if (metrics.pValue !== undefined) {
    metrics.conclusionValid = metrics.pValue < 0.05;
  } else if (metrics.bayesFactor !== undefined) {
    metrics.conclusionValid = metrics.bayesFactor > 3;
  }
  
  return Object.keys(metrics).length > 0 ? metrics : undefined;
}

/**
 * Simple test to verify Pyodide is working
 */
export async function testPyodide(): Promise<boolean> {
  try {
    const result = await validateProtocol(`
import numpy as np
result = np.mean([1, 2, 3, 4, 5])
print(f"Mean: {result}")
print(f"p-value: 0.03")
`);
    
    console.log('[ProtocolValidator] Test result:', result);
    return result.success && result.stdout.includes('Mean: 3.0');
  } catch (error) {
    console.error('[ProtocolValidator] Test failed:', error);
    return false;
  }
}
